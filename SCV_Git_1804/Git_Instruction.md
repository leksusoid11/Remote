![logo](Git-Logo-1788C.png )

# Работа с Git

## 1. Проверка установленного Git

В терминале выполнить команду `git version`
Если Gitустановлен, появится сообщение с информацией о версии файла. Иначе будет сообщение об ошибке.

## 2.  Установка Git

Загружаем последнюю версию Git с сайта <<https://git> -scm.com/downlouds>.
Устонавливаем с настройками по умолчанию.

## 3. Настройка Git

При первом использовании Git необходимо представиться.
Для этого нужно ввести в терминале две команды:

```
git config --global user.name "Ваше имя"
git config --global user.email "почта@exemple.com"
```

## 4. Инициализация репозитория

Получить репозиторий можно получить двумя способами.

* В терминале переходим к папке, в которой хотим создать репозиторий.
Выполняем команду `git init`
В исходной папке появится скрытая папка *.git* содержащая все необходимые файлы репозитория - структуру Git репозитория.
* Клонировать существующий репозиторий Git
Сделать это можно командой:

```
git clone <адрес репозитория>
```

## 5. Запись изменений в репозиторий

Чтобы посмотреть состояние файлов в репозитории необходимо выполнить команду:

```
git status
```

Для того, чтобы начать отслеживать новый файл используется команда:

```
git add <имя файла с расширением>
```

Так же для постепенного «добавления» изменений в индекс перед использованием команды фиксации используется команда

```
git add "имя файла с расширением"
```

Для   записи индексированных изменений в репозиторий, используется команда

```
git commit
```

Для анализа добавленных изменений и исправления возможных ошибок. Используют по необходимости

```
git diff
```

## 6. Просмотр истории коммитов

Для просмотра истории коммитов используется команда:

```
git log
```

Данная команда перечисляет коммиты с их хеш-кодами, именем, электронной почтой, датой создания и сообщением коммита.
По умолчанию последнии коммиты находятся вверху.

Для выхода из режима просмотра истории используется клавиша **"Q"**

## 7. Перемещение между сохранениями (коммитами)

Чтобы перейти к нужному сохранению (коммиту) можно использовать команду

```
git checkout <хеш-код>
```

 Пример использования команды `git checkout`

```
git checkout 40c1314
```

Такой переход можно использовать только для просмотра!
Продолжить работу над файлом можно только после перехода на верх ветки командой:

```
git checkout master
```
## 8. Ветвление.
Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

- Уже рабочая, стабильная версия кода сохраняется.
- Различные новые функции могут разрабатываться параллельно разными программистами.
- Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
- В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

### Создание новой ветки.
Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name> - название новой ветки
```
$ git branch amazing_new_feature
```
Это создаст новую ветку, пока что точную копию ветки `master`.

### Переключение между ветками.
Сейчас, если мы запустим branch, мы увидим две доступные опции:
```
$ git branch
amazing_new_feature
* master
```
`master` — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой `checkout`, она принимает один параметр — имя ветки, на которую необходимо переключиться.
```
$ git checkout amazing_new_feature
```
В Git ветка — это отдельная линия разработки.` Git checkout` позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды `git stash`, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.
### Слияние веток.
Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием `feature.txt.` Мы создадим его, добавим и закоммитим:
```
$ git add feature.txt
$ git commit -m "New feature complete.”
```
Изменения завершены, теперь мы можем переключиться обратно на ветку `master`.
```
$ git checkout master
```
Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла `feature.txt`, потому что мы переключились обратно на ветку `master`, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться `merge` для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта).
```
$ git merge amazing_new_feature
```
Теперь ветка master актуальна. Ветка `amazing_new_feature` больше не нужна, и ее можно удалить.
```
$ git branch -d awesome_new_feature
```
Если хотите создать копию удаленного репозитория - используйте `git clone`. Однако если вам нужна только определенная его ветка, а не все хранилище - после `git clone` выполните следующую команду в соответствующем репозитории:
```
git checkout -b <имя ветки> origin/<имя ветки>
```
После этого, новая ветка создается на машине автоматически.
##  Разрешение конфликтов при слиянии.
Rонфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и `tim_branch`. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:
```
// Use a for loop to console.log contents.
for(var i=0; i<arr.length; i++) {
console.log(arr[i]);
}
```
Тим предпочитает forEach:
```
// Use forEach to console.log contents.
arr.forEach(function(item) {
console.log(item);
});
```
Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:
```
$ git merge tim_branch
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
```
Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:
```
<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.
```
Над разделителем` ======= `мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.
```
// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());
```
Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:
```
$ git add -A
$ git commit -m "Array printing conflict resolved."
```
Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать `git mergetool`
### Как удалять ветки в Git?
Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:
```
git branch -d local_branch_name
```
где флажок` -d` являющийся опцией команды `git branch` - это сокращенная версия ключевого слова `--delete`, предназначенного для удаления ветки, а `local_branch_name` – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:
```
Error: Cannot delete branch local_branch_name checked out at название_директории
```
Так что при удалении ветвей, обязательно переключитесь на другой `branch`.

## 9. Игнорирование файлов.
Файл *.gitignore указывает намеренно неотслеживаемые файлы, которые Git должен игнорировать. Файлы, уже отслеженные Git, не затрагиваются
### Создание .gitignore
 Файл может находиться в корне проекта или любом подкаталоге.
Либо можно задать глобальный файл *.gitignore*, таким образом:
```
$ git config --global core.excludesfile ~/.gitignore_global
```
### Настройка .gitignore
- Измените gitignore , чтобы включить типы файлов, пути и шаблоны файлов в репозитории. Git начинает игнорировать эти файлы сразу после обновления .gitignore. Если другим пользователям в вашей команде нужен тот же набор игнорируемых файлов, обязательно зафиксируйте изменения.

- Каждая строка в *.gitignore* исключает файл или набор файлов, соответствующих шаблону.

Каждая строка в *.gitignore* файле определяет шаблон. При принятии решения об игнорировании пути Git обычно проверяет шаблоны из нескольких источников со следующим порядком приоритета, от высшего к низшему (в рамках одного уровня приоритета последний совпадающий шаблон определяет результат):

### Игнорировать файлы только в системе
Gitignore предоставляется всем участникам команды в виде файла, зафиксированного и отправленного в репозиторий Git. Чтобы исключить файлы только в системе, измените файл `GIT/info/exclude` в локальном репозитории. Изменения в этом файле не передаются другим пользователям.Они применяются только к файлам в этом репозитории.
### Игнорировать файлы во всех репозиториях в системе
 Настройте глобальный gitignore для использования во всех репозиториях в системе с помощью программы командной строки git config , как показано в следующем примере:
 ```
 git config core.excludesfile C:\Users\frank\.gitignore_global
 ```
 Этот подход полезен для игнорирования целых типов файлов, которые вы не хотите зафиксировать, например скомпилированные двоичные файлы.

### Игнорировать изменения в зафиксированных файлах
Во время разработки удобно прекратить отслеживание изменений в файле, зафиксированном в репозитории Git. Этот подход полезен при настройке параметров или файлов конфигурации, которые являются частью источника проекта для собственной рабочей среды.
 ```
 git update-index --skip-worktree <file>
 ```
 Возобновление отслеживания файлов с помощью следующей команды:
 ```
 git update-index --no-skip-worktree <file>
 ```
 Чтобы отключить отслеживание изменений, выполните приведенные действия.
 ```
 git update-index --assume-unchanged <file>
 ```
 Чтобы возобновить отслеживание изменений, выполните приведенные действия.
 ```
 git update-index --no-assume-unchanged <file>
 ```
 ### Постоянное прекращение отслеживания файла
Если файл уже отслеживается Git, .gitignore не применяется. Git продолжит отслеживать изменения в этом файле.
Если вы хотите прекратить отслеживание файла, необходимо явно сообщить Git, что он удален из отслеживания. Следуя этим указаниям, файл останется в локальном рабочем каталоге, но больше не будет отслеживаться в Git.
1. Добавьте файл в папку .gitignore.
2. Выполните следующую команду:
```
git rm --cached  <file>
```     
3. Зафиксируйте удаление файла и обновленный `gitignore` в репозитории.

